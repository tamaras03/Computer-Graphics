import {
	BackSide,
	BoxGeometry,
	Mesh,
	PerspectiveCamera,
	Scene,
	ShaderLib,
	ShaderMaterial,
	UniformsUtils
} from 'three';
import { Pass } from './Pass.js';

<<<<<<< HEAD
class CubeTexturePass extends Pass {

=======
/**
 * This pass can be used to render a cube texture over the entire screen.
 *
 * ```js
 * const cubeMap = new THREE.CubeTextureLoader().load( urls );
 *
 * const cubeTexturePass = new CubeTexturePass( camera, cubemap );
 * composer.addPass( cubeTexturePass );
 * ```
 *
 * @augments Pass
 * @three_import import { CubeTexturePass } from 'three/addons/postprocessing/CubeTexturePass.js';
 */
class CubeTexturePass extends Pass {

	/**
	 * Constructs a new cube texture pass.
	 *
	 * @param {PerspectiveCamera} camera - The camera.
	 * @param {CubeTexture} tCube - The cube texture to render.
	 * @param {number} [opacity=1] - The opacity.
	 */
>>>>>>> 50c6784a0819c7177d83555e6a1624cb4553e499
	constructor( camera, tCube, opacity = 1 ) {

		super();

<<<<<<< HEAD
		this.camera = camera;

		this.needsSwap = false;

		this.cubeShader = ShaderLib[ 'cube' ];
		this.cubeMesh = new Mesh(
			new BoxGeometry( 10, 10, 10 ),
			new ShaderMaterial( {
				uniforms: UniformsUtils.clone( this.cubeShader.uniforms ),
				vertexShader: this.cubeShader.vertexShader,
				fragmentShader: this.cubeShader.fragmentShader,
=======
		/**
		 * The camera.
		 *
		 * @type {PerspectiveCamera}
		 */
		this.camera = camera;

		/**
		 * The cube texture to render.
		 *
		 * @type {CubeTexture}
		 */
		this.tCube = tCube;

		/**
		 * The opacity.
		 *
		 * @type {number}
		 * @default 1
		 */
		this.opacity = opacity;

		/**
		 * Overwritten to disable the swap.
		 *
		 * @type {boolean}
		 * @default false
		 */
		this.needsSwap = false;

		// internals

		const cubeShader = ShaderLib[ 'cube' ];

		this._cubeMesh = new Mesh(
			new BoxGeometry( 10, 10, 10 ),
			new ShaderMaterial( {
				uniforms: UniformsUtils.clone( cubeShader.uniforms ),
				vertexShader: cubeShader.vertexShader,
				fragmentShader: cubeShader.fragmentShader,
>>>>>>> 50c6784a0819c7177d83555e6a1624cb4553e499
				depthTest: false,
				depthWrite: false,
				side: BackSide
			} )
		);

<<<<<<< HEAD
		Object.defineProperty( this.cubeMesh.material, 'envMap', {
=======
		Object.defineProperty( this._cubeMesh.material, 'envMap', {
>>>>>>> 50c6784a0819c7177d83555e6a1624cb4553e499

			get: function () {

				return this.uniforms.tCube.value;

			}

		} );

<<<<<<< HEAD
		this.tCube = tCube;
		this.opacity = opacity;

		this.cubeScene = new Scene();
		this.cubeCamera = new PerspectiveCamera();
		this.cubeScene.add( this.cubeMesh );

	}

=======
		this._cubeScene = new Scene();
		this._cubeCamera = new PerspectiveCamera();
		this._cubeScene.add( this._cubeMesh );

	}

	/**
	 * Performs the cube texture pass.
	 *
	 * @param {WebGLRenderer} renderer - The renderer.
	 * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
	 * destination for the pass.
	 * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
	 * previous pass from this buffer.
	 * @param {number} deltaTime - The delta time in seconds.
	 * @param {boolean} maskActive - Whether masking is active or not.
	 */
>>>>>>> 50c6784a0819c7177d83555e6a1624cb4553e499
	render( renderer, writeBuffer, readBuffer/*, deltaTime, maskActive*/ ) {

		const oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

<<<<<<< HEAD
		this.cubeCamera.projectionMatrix.copy( this.camera.projectionMatrix );
		this.cubeCamera.quaternion.setFromRotationMatrix( this.camera.matrixWorld );

		this.cubeMesh.material.uniforms.tCube.value = this.tCube;
		this.cubeMesh.material.uniforms.tFlip.value = ( this.tCube.isCubeTexture && this.tCube.isRenderTargetTexture === false ) ? - 1 : 1;
		this.cubeMesh.material.uniforms.opacity.value = this.opacity;
		this.cubeMesh.material.transparent = ( this.opacity < 1.0 );

		renderer.setRenderTarget( this.renderToScreen ? null : readBuffer );
		if ( this.clear ) renderer.clear();
		renderer.render( this.cubeScene, this.cubeCamera );
=======
		this._cubeCamera.projectionMatrix.copy( this.camera.projectionMatrix );
		this._cubeCamera.quaternion.setFromRotationMatrix( this.camera.matrixWorld );

		this._cubeMesh.material.uniforms.tCube.value = this.tCube;
		this._cubeMesh.material.uniforms.tFlip.value = ( this.tCube.isCubeTexture && this.tCube.isRenderTargetTexture === false ) ? - 1 : 1;
		this._cubeMesh.material.uniforms.opacity.value = this.opacity;
		this._cubeMesh.material.transparent = ( this.opacity < 1.0 );

		renderer.setRenderTarget( this.renderToScreen ? null : readBuffer );
		if ( this.clear ) renderer.clear();
		renderer.render( this._cubeScene, this._cubeCamera );
>>>>>>> 50c6784a0819c7177d83555e6a1624cb4553e499

		renderer.autoClear = oldAutoClear;

	}

<<<<<<< HEAD
	dispose() {

		this.cubeMesh.geometry.dispose();
		this.cubeMesh.material.dispose();
=======
	/**
	 * Frees the GPU-related resources allocated by this instance. Call this
	 * method whenever the pass is no longer used in your app.
	 */
	dispose() {

		this._cubeMesh.geometry.dispose();
		this._cubeMesh.material.dispose();
>>>>>>> 50c6784a0819c7177d83555e6a1624cb4553e499

	}

}

export { CubeTexturePass };
