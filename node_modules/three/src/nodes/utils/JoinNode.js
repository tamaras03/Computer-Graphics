import TempNode from '../core/TempNode.js';

<<<<<<< HEAD
=======
/**
 * This module is part of the TSL core and usually not used in app level code.
 * It represents a join operation during the shader generation process.
 * For example in can compose/join two single floats into a `vec2` type.
 *
 * @augments TempNode
 */
>>>>>>> 50c6784a0819c7177d83555e6a1624cb4553e499
class JoinNode extends TempNode {

	static get type() {

		return 'JoinNode';

	}

<<<<<<< HEAD
=======
	/**
	 * Constructs a new join node.
	 *
	 * @param {Array<Node>} nodes - An array of nodes that should be joined.
	 * @param {?string} [nodeType=null] - The node type.
	 */
>>>>>>> 50c6784a0819c7177d83555e6a1624cb4553e499
	constructor( nodes = [], nodeType = null ) {

		super( nodeType );

<<<<<<< HEAD
=======
		/**
		 * An array of nodes that should be joined.
		 *
		 * @type {Array<Node>}
		 */
>>>>>>> 50c6784a0819c7177d83555e6a1624cb4553e499
		this.nodes = nodes;

	}

<<<<<<< HEAD
=======
	/**
	 * This method is overwritten since the node type must be inferred from the
	 * joined data length if not explicitly defined.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {string} The node type.
	 */
>>>>>>> 50c6784a0819c7177d83555e6a1624cb4553e499
	getNodeType( builder ) {

		if ( this.nodeType !== null ) {

			return builder.getVectorType( this.nodeType );

		}

		return builder.getTypeFromLength( this.nodes.reduce( ( count, cur ) => count + builder.getTypeLength( cur.getNodeType( builder ) ), 0 ) );

	}

	generate( builder, output ) {

		const type = this.getNodeType( builder );
<<<<<<< HEAD
=======
		const maxLength = builder.getTypeLength( type );

>>>>>>> 50c6784a0819c7177d83555e6a1624cb4553e499
		const nodes = this.nodes;

		const primitiveType = builder.getComponentType( type );

		const snippetValues = [];

<<<<<<< HEAD
		for ( const input of nodes ) {

			let inputSnippet = input.build( builder );

			const inputPrimitiveType = builder.getComponentType( input.getNodeType( builder ) );

			if ( inputPrimitiveType !== primitiveType ) {

				inputSnippet = builder.format( inputSnippet, inputPrimitiveType, primitiveType );
=======
		let length = 0;

		for ( const input of nodes ) {

			if ( length >= maxLength ) {

				console.error( `THREE.TSL: Length of parameters exceeds maximum length of function '${ type }()' type.` );
				break;

			}

			let inputType = input.getNodeType( builder );
			let inputTypeLength = builder.getTypeLength( inputType );
			let inputSnippet;

			if ( length + inputTypeLength > maxLength ) {

				console.error( `THREE.TSL: Length of '${ type }()' data exceeds maximum length of output type.` );

				inputTypeLength = maxLength - length;
				inputType = builder.getTypeFromLength( inputTypeLength );

			}

			length += inputTypeLength;
			inputSnippet = input.build( builder, inputType );

			const inputPrimitiveType = builder.getComponentType( inputType );

			if ( inputPrimitiveType !== primitiveType ) {

				const targetType = builder.getTypeFromLength( inputTypeLength, primitiveType );

				inputSnippet = builder.format( inputSnippet, inputType, targetType );
>>>>>>> 50c6784a0819c7177d83555e6a1624cb4553e499

			}

			snippetValues.push( inputSnippet );

		}

		const snippet = `${ builder.getType( type ) }( ${ snippetValues.join( ', ' ) } )`;

		return builder.format( snippet, type, output );

	}

}

export default JoinNode;
