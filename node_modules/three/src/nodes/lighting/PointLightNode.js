import AnalyticLightNode from './AnalyticLightNode.js';
import { getDistanceAttenuation } from './LightUtils.js';
import { uniform } from '../core/UniformNode.js';
<<<<<<< HEAD
import { lightViewPosition } from '../accessors/Lights.js';
import { positionView } from '../accessors/Position.js';
import { Fn } from '../tsl/TSLBase.js';
import { renderGroup } from '../core/UniformGroupNode.js';

export const directPointLight = Fn( ( { color, lightViewPosition, cutoffDistance, decayExponent }, builder ) => {

	const lightingModel = builder.context.lightingModel;

	const lVector = lightViewPosition.sub( positionView ); // @TODO: Add it into LightNode

	const lightDirection = lVector.normalize();
	const lightDistance = lVector.length();

	const lightAttenuation = getDistanceAttenuation( {
=======
import { renderGroup } from '../core/UniformGroupNode.js';
import { pointShadow } from './PointShadowNode.js';

export const directPointLight = ( { color, lightVector, cutoffDistance, decayExponent } ) => {

	const lightDirection = lightVector.normalize();
	const lightDistance = lightVector.length();

	const attenuation = getDistanceAttenuation( {
>>>>>>> 50c6784a0819c7177d83555e6a1624cb4553e499
		lightDistance,
		cutoffDistance,
		decayExponent
	} );

<<<<<<< HEAD
	const lightColor = color.mul( lightAttenuation );

	const reflectedLight = builder.context.reflectedLight;

	lightingModel.direct( {
		lightDirection,
		lightColor,
		reflectedLight
	}, builder.stack, builder );

} );

=======
	const lightColor = color.mul( attenuation );

	return { lightDirection, lightColor };

};

/**
 * Module for representing point lights as nodes.
 *
 * @augments AnalyticLightNode
 */
>>>>>>> 50c6784a0819c7177d83555e6a1624cb4553e499
class PointLightNode extends AnalyticLightNode {

	static get type() {

		return 'PointLightNode';

	}

<<<<<<< HEAD
=======
	/**
	 * Constructs a new point light node.
	 *
	 * @param {?PointLight} [light=null] - The point light source.
	 */
>>>>>>> 50c6784a0819c7177d83555e6a1624cb4553e499
	constructor( light = null ) {

		super( light );

<<<<<<< HEAD
		this.cutoffDistanceNode = uniform( 0 ).setGroup( renderGroup );
		this.decayExponentNode = uniform( 0 ).setGroup( renderGroup );

	}

=======
		/**
		 * Uniform node representing the cutoff distance.
		 *
		 * @type {UniformNode<float>}
		 */
		this.cutoffDistanceNode = uniform( 0 ).setGroup( renderGroup );

		/**
		 * Uniform node representing the decay exponent.
		 *
		 * @type {UniformNode<float>}
		 */
		this.decayExponentNode = uniform( 2 ).setGroup( renderGroup );

	}

	/**
	 * Overwritten to updated point light specific uniforms.
	 *
	 * @param {NodeFrame} frame - A reference to the current node frame.
	 */
>>>>>>> 50c6784a0819c7177d83555e6a1624cb4553e499
	update( frame ) {

		const { light } = this;

		super.update( frame );

		this.cutoffDistanceNode.value = light.distance;
		this.decayExponentNode.value = light.decay;

	}

<<<<<<< HEAD
	setup() {

		directPointLight( {
			color: this.colorNode,
			lightViewPosition: lightViewPosition( this.light ),
			cutoffDistance: this.cutoffDistanceNode,
			decayExponent: this.decayExponentNode
		} ).append();
=======
	/**
	 * Overwritten to setup point light specific shadow.
	 *
	 * @return {PointShadowNode}
	 */
	setupShadowNode() {

		return pointShadow( this.light );

	}

	setupDirect( builder ) {

		return directPointLight( {
			color: this.colorNode,
			lightVector: this.getLightVector( builder ),
			cutoffDistance: this.cutoffDistanceNode,
			decayExponent: this.decayExponentNode
		} );
>>>>>>> 50c6784a0819c7177d83555e6a1624cb4553e499

	}

}

export default PointLightNode;
